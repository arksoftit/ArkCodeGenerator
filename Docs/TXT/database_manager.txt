# database_manager.py

import os
import sqlite3
from sqlite3 import Error

class DatabaseManager:
    """
    Clase para manejar la conexión y operaciones con la base de datos SQLite 
    llamada 'arkcogenDB.sqlite'.
    """
    # Validación de infraestructura: Verificar existencia del archivo y las tablas clave
    
    def validate_infrastructure(self):
        """
        ID=MDACG26020003: Valida existencia de archivo y las 5 tablas clave.
        Retorna (bool, mensaje)
        """
        # 1. Validar existencia del archivo físico
        if not os.path.exists(self.db_path):
            return False, f"Error: No se encontró el archivo en {self.db_path}"

        tablas_a_validar = [
            "ark_company", 
            "ark_clients", 
            "ark_levels", 
            "ark_auto_code_generator", 
            "ark_users"
        ]
        faltantes = []

        try:
            # Conexión en modo lectura para evitar creación accidental
            conn = sqlite3.connect(f"file:{self.db_path}?mode=rw", uri=True)
            cursor = conn.cursor()
            
            for tabla in tablas_a_validar:
                cursor.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name='{tabla}';")
                if not cursor.fetchone():
                    faltantes.append(tabla)
            
            conn.close()

            if faltantes:
                return False, f"Base de datos OK, pero faltan tablas: {', '.join(faltantes)}"
            
            return True, "Infraestructura de base de datos validada: Archivo y 5 tablas OK."

        except sqlite3.Error as e:
            return False, f"Error de acceso a la base de datos: {str(e)}"
        
    #Creación de la base de datos y tablas (si no existen)
    
    def __init__(self, db_folder="arkcogendatabase", db_name="arkcogenDB.sqlite"):
        """Inicializa la ruta a la base de datos de manera relativa."""
        # Se construye la ruta: [Directorio de ejecución]/arkcogendatabase/arkcogenDB.sqlite
        self.db_path = os.path.join(os.getcwd(), db_folder, db_name)
        
        # Script SQL completo (se recomienda cargarlo desde un archivo externo para proyectos grandes)
        self.sql_script = """
PRAGMA foreign_keys = ON;

-- 1-Empresas
CREATE TABLE IF NOT EXISTS ark_company (
    emp_IDauto INTEGER PRIMARY KEY AUTOINCREMENT,
    emp_Codigo TEXT NOT NULL,
    emp_Descripcion TEXT,
    emp_IDfiscal TEXT,
    emp_Status INTEGER DEFAULT 1,
    emp_DireccionF TEXT,
    emp_DireccionL TEXT,
    emp_Telefono1 TEXT,
    emp_Telefono2 TEXT,
    emp_Representante TEXT,
    emp_IDRepresentante TEXT,
    emp_TelefonoContacto TEXT,
    emp_EmailContacto TEXT,
    emp_EmailEmpresa TEXT,
    emp_TipoContribuyente INTEGER,
    emp_FechaCreacion TEXT DEFAULT (datetime('now')),
    emp_systemdate TEXT, 
    emp_systemtime TEXT,
    emp_namemachine TEXT,
    emp_usercreator TEXT,
    emp_lastupdatedate TEXT,
    emp_lastupdatetime TEXT,
    emp_lastmachine TEXT,
    emp_userlastupdate TEXT
);

-- 2-Clientes
CREATE TABLE IF NOT EXISTS ark_clients (
    clt_IDauto INTEGER PRIMARY KEY AUTOINCREMENT,
    clt_Codigo TEXT NOT NULL,
    clt_Descripcion TEXT,
    clt_IDfiscal TEXT,
    clt_Status INTEGER DEFAULT 1,
    clt_DireccionF TEXT,
    clt_DireccionL TEXT,
    clt_Telefono1 TEXT,
    clt_Telefono2 TEXT,
    clt_Representante TEXT,
    clt_IDRepresentante TEXT,
    clt_TelefonoContacto TEXT,
    clt_EmailContacto TEXT,
    clt_EmailEmpresa TEXT,
    clt_TipoContribuyente INTEGER,
    clt_Origen TEXT,
    clt_CodigoOrigen TEXT,
    clt_FechaCreacion TEXT DEFAULT (datetime('now')),
    clt_systemdate TEXT, 
    clt_systemtime TEXT,
    clt_namemachine TEXT,
    clt_usercreator TEXT,
    clt_lastupdatedate TEXT,
    clt_lastupdatetime TEXT,
    clt_lastmachine TEXT,
    clt_userlastupdate TEXT
);

-- 3-Niveles
CREATE TABLE IF NOT EXISTS ark_levels (
    lvs_IDauto INTEGER PRIMARY KEY AUTOINCREMENT, 
    lvs_code TEXT NOT NULL, 
    lvs_description TEXT, 
    lvs_descriptionTec TEXT,
    lvs_level_type TEXT,
    lvs_level_parente TEXT,
    lvs_Number_of_digits TEXT,
    lvs_Special_characters TEXT,
    lvs_Level_separator TEXT,
    lvs_Alphanumeric TEXT,
    lvs_Status INTEGER DEFAULT 1, 
    lvs_create_date TEXT DEFAULT (datetime('now')), 
    lvs_systemdate TEXT, 
    lvs_systemtime TEXT,
    lvs_namemachine TEXT,
    lvs_usercreator TEXT,
    lvs_lastupdatedate TEXT,
    lvs_lastupdatetime TEXT,
    lvs_lastmachine TEXT,
    lvs_userlastupdate TEXT
);
-- 4-ark_auto_code_generator
CREATE TABLE IF NOT EXISTS ark_auto_code_generator (
    acg_Idauto INTEGER PRIMARY KEY AUTOINCREMENT,
    acg_codeid TEXT NOT NULL, 
    acg_first_level TEXT,
    acg_second_level TEXT,
    acg_third_level TEXT,
    acg_fourth_level TEXT,
    acg_fifth_level TEXT, 
    acg_auto_code TEXT,
    acg_create_date TEXT DEFAULT (datetime('now')), 
    acg_systemdate TEXT, 
    acg_systemtime TEXT,
    acg_namemachine TEXT,
    acg_usercreator TEXT,
    acg_lastupdatedate TEXT,
    acg_lastupdatetime TEXT,
    acg_lastmachine TEXT,
    acg_userlastupdate TEXT
);
-- 5-Usuarios
CREATE TABLE IF NOT EXISTS ark_users (
    usr_Idauto INTEGER PRIMARY KEY AUTOINCREMENT,
    usr_Codigo TEXT NOT NULL,
    usr_username TEXT NOT NULL,
    usr_Descripcion TEXT,
    usr_Status INTEGER DEFAULT 1,
    usr_Telefono TEXT,
    usr_Cargo TEXT,
    usr_Rol TEXT,
    usr_Emailuser TEXT,
    usr_Password TEXT,
    usr_FechaCreacion TEXT   DEFAULT (datetime('now')),
    usr_systemdate TEXT, 
    usr_systemtime TEXT,
    usr_namemachine TEXT,
    usr_usercreator TEXT,
    usr_lastupdatedate TEXT,
    usr_lastupdatetime TEXT,
    usr_lastmachine TEXT,
    usr_userlastupdate TEXT
);
"""

    def create_connection(self):
        """Crea una conexión a la base de datos SQLite.
        """
        conn = None
        # Crea la carpeta si no existe (arkcogendatabase)
        db_dir = os.path.dirname(self.db_path)
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)

        try:
            conn = sqlite3.connect(self.db_path)
            return conn
        except Error as e:
            # En un entorno PySide6, es mejor usar logging o QMessageBox
            print(f"Error al conectar con SQLite: {e}")
            return None

    def setup_database(self):
        """Crea las tablas si la base de datos es nueva/está vacía."""
        conn = self.create_connection()
        if conn is not None:
            try:
                cursor = conn.cursor()
                # Ejecuta el script completo para crear todas las tablas
                cursor.executescript(self.sql_script)
                conn.commit()
            except Error as e:
                print(f"Error al configurar la base de datos: {e}")
            finally:
                if conn:
                    conn.close()

    def execute_query(self, sql_query, params=()):
        """Ejecuta consultas INSERT, UPDATE, DELETE y retorna el cursor."""
        conn = self.create_connection()
        cursor = None
        if conn is not None:
            try:
                cursor = conn.cursor()
                cursor.execute(sql_query, params)
                conn.commit()
                return cursor
            except Error as e:
                print(f"Error al ejecutar la consulta: {e}")
                return None
            finally:
                # La conexión se cierra aquí para asegurar que los cambios se guarden.
                if conn:
                    conn.close()

    def fetch_data(self, sql_query, params=()):
        """Ejecuta consultas SELECT y retorna todos los resultados como diccionarios."""
        conn = self.create_connection()
        rows = []
        if conn is not None:
            try:
                # Usamos row_factory para obtener resultados accesibles por nombre de columna (como diccionarios)
                conn.row_factory = sqlite3.Row 
                cursor = conn.cursor()
                cursor.execute(sql_query, params)
                rows = cursor.fetchall()
            except Error as e:
                print(f"Error al obtener datos: {e}")
            finally:
                if conn:
                    conn.close()
        return rows
    
    def get_detailed_stats(self):
        """
        ID=MDACG26020005: Obtiene nombres de tablas, conteo de columnas y registros.
        """
        stats = []
        tablas = ["ark_company", "ark_clients", "ark_levels", "ark_auto_code_generator", "ark_users"]
        
        conn = self.create_connection()
        if conn:
            try:
                cursor = conn.cursor()
                for tabla in tablas:
                    # 1. Cantidad de Columnas
                    cursor.execute(f"PRAGMA table_info({tabla});")
                    columnas = len(cursor.fetchall())
                    
                    # 2. Cantidad de Registros
                    cursor.execute(f"SELECT COUNT(*) FROM {tabla};")
                    registros = cursor.fetchone()[0]
                    
                    stats.append({
                        'tabla': tabla,
                        'columnas': columnas,
                        'registros': registros
                    })
            except Exception as e:
                print(f"Error al obtener estadísticas: {e}")
            finally:
                conn.close()
        return stats